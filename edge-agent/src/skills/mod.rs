pub mod gpio;
pub mod price_monitor;
pub mod registry;
pub mod system_monitor;

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use serde_json::Value;

/// Report generated by a skill's periodic tick
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SkillReport {
    pub skill: String,
    pub report_type: String, // "metric", "alert", "data"
    pub payload: Value,
}

/// Information about a skill for status queries
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SkillInfo {
    pub name: String,
    pub enabled: bool,
    pub capabilities: Vec<String>,
    pub tick_interval_secs: u64,
    pub last_tick: Option<u64>,
}

/// Every agent skill implements this trait
#[async_trait]
pub trait Skill: Send + Sync {
    /// Unique skill name
    fn name(&self) -> &str;

    /// List of capabilities this skill provides
    fn capabilities(&self) -> Vec<String>;

    /// Initialize the skill (called once at startup)
    async fn init(&mut self) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;

    /// Handle a command from the orchestrator
    async fn handle(
        &mut self,
        command: &str,
        payload: Value,
    ) -> Result<Value, Box<dyn std::error::Error + Send + Sync>>;

    /// Periodic tick â€” return Some(report) to send data to orchestrator
    async fn tick(&mut self) -> Option<SkillReport>;

    /// Tick interval in seconds (0 = no periodic ticking)
    fn tick_interval_secs(&self) -> u64;

    /// Shutdown the skill gracefully
    async fn shutdown(&mut self) {}
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_skill_report_serialization() {
        let report = SkillReport {
            skill: "system_monitor".to_string(),
            report_type: "metric".to_string(),
            payload: serde_json::json!({"cpu_pct": 12.5}),
        };
        let json = serde_json::to_string(&report).unwrap();
        let deserialized: SkillReport = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.skill, "system_monitor");
        assert_eq!(deserialized.report_type, "metric");
        assert_eq!(deserialized.payload["cpu_pct"], 12.5);
    }

    #[test]
    fn test_skill_report_clone() {
        let report = SkillReport {
            skill: "gpio".to_string(),
            report_type: "alert".to_string(),
            payload: serde_json::json!({"pin": 17}),
        };
        let cloned = report.clone();
        assert_eq!(report.skill, cloned.skill);
        assert_eq!(report.report_type, cloned.report_type);
    }

    #[test]
    fn test_skill_info_serialization() {
        let info = SkillInfo {
            name: "system_monitor".to_string(),
            enabled: true,
            capabilities: vec!["system.cpu".to_string(), "system.memory".to_string()],
            tick_interval_secs: 30,
            last_tick: Some(1234567890),
        };
        let json = serde_json::to_string(&info).unwrap();
        let deserialized: SkillInfo = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.name, "system_monitor");
        assert!(deserialized.enabled);
        assert_eq!(deserialized.capabilities.len(), 2);
        assert_eq!(deserialized.tick_interval_secs, 30);
        assert_eq!(deserialized.last_tick, Some(1234567890));
    }

    #[test]
    fn test_skill_info_no_last_tick() {
        let info = SkillInfo {
            name: "gpio".to_string(),
            enabled: false,
            capabilities: vec![],
            tick_interval_secs: 0,
            last_tick: None,
        };
        let json = serde_json::to_string(&info).unwrap();
        let deserialized: SkillInfo = serde_json::from_str(&json).unwrap();
        assert!(!deserialized.enabled);
        assert!(deserialized.last_tick.is_none());
    }

    #[test]
    fn test_skill_report_debug() {
        let report = SkillReport {
            skill: "test".to_string(),
            report_type: "data".to_string(),
            payload: serde_json::json!(null),
        };
        let debug_str = format!("{:?}", report);
        assert!(debug_str.contains("test"));
        assert!(debug_str.contains("data"));
    }
}
